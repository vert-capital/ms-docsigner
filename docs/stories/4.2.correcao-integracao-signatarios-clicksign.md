# Story 4.2: Correção Integração Signatários Clicksign API

## Status

Ready for Review

## Story

**Como** desenvolvedor utilizando a API do ms-docsigner,
**Eu quero** que o sistema corrija os problemas de integração com a API de signatários da Clicksign (`/api/v3/envelopes/{{envelope_id}}/signers`),
**Para que** as operações de criação, atualização e remoção de signatários sejam sincronizadas corretamente entre o sistema local e a Clicksign, garantindo que atualizações realizadas via `PUT /api/v1/signatories/{id}` sejam refletidas na plataforma Clicksign.

## Acceptance Criteria

1. A operação UpdateSignatory deve integrar com a API Clicksign para atualizar signatários remotamente
2. A operação DeleteSignatory deve integrar com a API Clicksign para remover signatários da plataforma
3. O método CreateSignatory deve ser revisado para garantir criação correta na Clicksign
4. Implementar mapeamento bidirecional entre EntitySignatory e estruturas Clicksign para todas as operações CRUD
5. Adicionar validações para verificar se o envelope possui ClicksignKey antes de operações na Clicksign
6. Implementar tratamento de erros robusto para falhas na integração Clicksign
7. Adicionar logging estruturado para todas as operações de sincronização com correlation_id
8. Criar testes unitários para validar integração de CRUD de signatários com Clicksign
9. Implementar rollback local em caso de falha nas operações remotas da Clicksign
10. Validar que signatários são corretamente identificados pela ClicksignKey nos updates/deletes
11. Documentar endpoints da Clicksign utilizados e estruturas de dados esperadas
12. Atualizar documentação Swagger com informações sobre sincronização Clicksign

## Tasks / Subtasks

- [ ] **TODO** Analisar problema atual de integração UPDATE (AC: 1, 4, 6, 7)
  
  - [ ] Investigar por que `PUT /api/v1/signatories/122` retorna 200 mas não atualiza na Clicksign
  - [ ] Verificar se UseCase UpdateSignatory está chamando serviços Clicksign corretamente  
  - [ ] Analisar se SignatoryMapper possui método ToClicksignUpdateRequest implementado
  - [ ] Verificar se SignerService possui método UpdateSigner funcional
  - [ ] Implementar logging detalhado para rastrear fluxo de atualização
  - [ ] Validar se ClicksignKey do signatário está sendo utilizada corretamente

- [ ] **TODO** Implementar integração UPDATE na Clicksign (AC: 1, 4, 5, 6)

  - [ ] Criar método UpdateSigner no SignerService para chamada PATCH/PUT na Clicksign
  - [ ] Implementar ToClicksignUpdateRequest no SignatoryMapper
  - [ ] Modificar UsecaseSignatoryService.UpdateSignatory para integrar com Clicksign
  - [ ] Adicionar validação de ClicksignKey antes de tentar atualizar remotamente
  - [ ] Implementar estruturas DTO para atualização de signatários na Clicksign
  - [ ] Tratar erros específicos da API Clicksign (404, 422, 500)

- [ ] **TODO** Implementar integração DELETE na Clicksign (AC: 2, 4, 5, 6)

  - [ ] Criar método DeleteSigner no SignerService para chamada DELETE na Clicksign
  - [ ] Modificar UsecaseSignatoryService.DeleteSignatory para integrar com Clicksign
  - [ ] Implementar validação de ClicksignKey antes de tentar deletar remotamente
  - [ ] Adicionar tratamento para casos onde signatário não existe na Clicksign
  - [ ] Implementar lógica de rollback se delete local falhar após delete remoto
  - [ ] Validar regras de negócio para delete (status do envelope, etc.)

- [ ] **TODO** Revisar e corrigir integração CREATE (AC: 3, 4, 5, 6)

  - [ ] Validar se método CreateSigner está funcionando corretamente
  - [ ] Verificar mapeamento de EntitySignatory para SignerData na criação
  - [ ] Testar criação de signatários com diferentes configurações (birthday, phone, etc.)
  - [ ] Validar se ClicksignKey está sendo armazenada corretamente após criação
  - [ ] Implementar validação de envelope ClicksignKey antes da criação
  - [ ] Testar rollback local em caso de falha na criação remota

- [ ] **TODO** Implementar mapeamento bidirecional completo (AC: 4)

  - [ ] Criar FromClicksignResponse no SignatoryMapper para operações GET
  - [ ] Implementar ToClicksignUpdateRequest para operações PATCH/PUT
  - [ ] Validar mapeamento de todos os campos (name, email, birthday, phone_number, etc.)
  - [ ] Implementar mapeamento de CommunicateEvents em ambas as direções
  - [ ] Testar mapeamento com diferentes configurações de signatários
  - [ ] Documentar campos obrigatórios vs opcionais no mapeamento

- [ ] **TODO** Implementar validações e tratamento de erros (AC: 5, 6, 9)

  - [ ] Adicionar validação de ClicksignKey não-vazia antes de operações remotas
  - [ ] Implementar tratamento específico para códigos de erro da Clicksign (400, 404, 422, 500)
  - [ ] Criar mensagens de erro descritivas para diferentes falhas de integração
  - [ ] Implementar retry lógico para erros temporários (timeouts, 503)
  - [ ] Implementar rollback de operações locais em caso de falha remota
  - [ ] Adicionar validação de envelope status antes de operações na Clicksign

- [ ] **TODO** Implementar logging estruturado completo (AC: 7)

  - [ ] Adicionar logs de início/fim para todas as operações CRUD na Clicksign
  - [ ] Implementar correlation_id em todos os logs de integração
  - [ ] Logar payloads de request/response da Clicksign (sanitizados)
  - [ ] Adicionar métricas de tempo de resposta das chamadas Clicksign
  - [ ] Implementar logs de erro com contexto detalhado para troubleshooting
  - [ ] Criar logs de auditoria para operações de sincronização

- [ ] **TODO** Implementar testes unitários abrangentes (AC: 8)

  - [ ] Criar testes para UpdateSignatory com mocks do SignerService
  - [ ] Implementar testes para DeleteSignatory com cenários de sucesso/falha
  - [ ] Testar CreateSignatory com diferentes configurações de dados
  - [ ] Criar testes para validação de ClicksignKey em todas as operações
  - [ ] Implementar testes de rollback para falhas na Clicksign
  - [ ] Testar mapeamento bidirecional com dados completos e parciais
  - [ ] Criar testes de integração end-to-end com mocks da Clicksign

- [ ] **TODO** Validar identificação por ClicksignKey (AC: 10)

  - [ ] Verificar se ClicksignKey está sendo utilizada nas operações UPDATE/DELETE
  - [ ] Implementar busca de signatários na Clicksign por ClicksignKey
  - [ ] Validar que operações usam ClicksignKey e não ID local do banco
  - [ ] Testar cenários onde ClicksignKey pode estar inconsistente
  - [ ] Implementar sincronização de ClicksignKey se necessário
  - [ ] Documentar estratégia de identificação de signatários entre sistemas

- [ ] **TODO** Atualizar documentação técnica (AC: 11, 12)

  - [ ] Documentar endpoints da Clicksign utilizados para signatários
  - [ ] Criar exemplos de payloads para CREATE/UPDATE/DELETE na Clicksign  
  - [ ] Atualizar Swagger com informações sobre sincronização Clicksign
  - [ ] Documentar fluxo de rollback em caso de falhas
  - [ ] Criar guia de troubleshooting para problemas de sincronização
  - [ ] Atualizar CLAUDE.md com comandos de debug para signatários

## Dev Notes

### Contexto do Problema Identificado

**Problema Reportado**:
- Chamada `PUT http://localhost:8080/api/v1/signatories/122` retorna 200 OK
- Porém a atualização não é refletida na plataforma Clicksign
- Necessário investigar e corrigir toda a integração CRUD de signatários

### Análise da Implementação Atual

**Arquivo**: `src/usecase/signatory/usecase_signatory_service.go`

**Método UpdateSignatory** (linhas 155-189):
```go
func (u *UsecaseSignatoryService) UpdateSignatory(signatory *entity.EntitySignatory) error {
    // Apenas atualiza localmente, SEM integração com Clicksign
    err = u.repositorySignatory.Update(signatory)
    return nil
}
```

**Problema Identificado**: O método `UpdateSignatory` apenas atualiza o registro local no banco de dados, não sincroniza com a Clicksign.

**Método DeleteSignatory** (linhas 191-213):
```go  
func (u *UsecaseSignatoryService) DeleteSignatory(id int) error {
    // Apenas deleta localmente, SEM integração com Clicksign
    err = u.repositorySignatory.Delete(signatory)
    return nil
}
```

**Problema Identificado**: O método `DeleteSignatory` apenas remove o registro local, não remove da Clicksign.

**Método CreateSignatory** (linhas 42-120):
```go
func (u *UsecaseSignatoryService) CreateSignatory(signatory *entity.EntitySignatory) (*entity.EntitySignatory, error) {
    // Possui integração com Clicksign via SignerService.CreateSigner
    clicksignSignerID, err := u.signerService.CreateSigner(ctx, envelope.ClicksignKey, signerData)
    signatory.SetClicksignKey(clicksignSignerID)
    return signatory, nil
}
```

**Status**: Implementação parcial - possui integração na criação, mas pode precisar de revisão.

### Análise da Coleção Postman Clicksign

**Endpoints Relevantes da Clicksign API v3**:

1. **Criar Signatário**: `POST /api/v3/envelopes/{{envelope_id}}/signers`
2. **Atualizar Signatário**: `PATCH /api/v3/signers/{{signer_id}}` (endpoint assumido)
3. **Deletar Signatário**: `DELETE /api/v3/signers/{{signer_id}}` (endpoint assumido)
4. **Listar Signatários**: `GET /api/v3/envelopes/{{envelope_id}}/signers`

**Estrutura de Dados Clicksign** (baseada na coleção Postman):
```json
{
    "data": {
        "type": "signers",
        "attributes": {
            "name": "Nome com Sobrenome",
            "email": "nome.sobrenome@example.com",
            "birthday": "2000-01-01",
            "phone_number": null,
            "has_documentation": true,
            "refusable": false,
            "group": 1,
            "communicate_events": {
                "document_signed": "email",
                "signature_request": "email", 
                "signature_reminder": "email"
            }
        }
    }
}
```

### Implementação da Infrastructure Layer

**Arquivo**: `src/infrastructure/clicksign/signer_service.go`

**Métodos Necessários**:
- `CreateSigner()` - ✅ Implementado
- `UpdateSigner()` - ❌ Não implementado  
- `DeleteSigner()` - ❌ Não implementado
- `GetSigner()` - ❌ Não implementado

**Arquivo**: `src/infrastructure/clicksign/signatory_mapper.go`

**Métodos Necessários**:
- `ToClicksignCreateRequest()` - ✅ Implementado
- `ToClicksignUpdateRequest()` - ❌ Não implementado
- `FromClicksignResponse()` - ❌ Não implementado

### Estrutura de Integração Proposta

**Fluxo UPDATE**:
1. Validar se signatory possui ClicksignKey
2. Validar se envelope permite modificações  
3. Atualizar signatário localmente
4. Mapear EntitySignatory → ClicksignUpdateRequest
5. Chamar PATCH /api/v3/signers/{{clicksign_key}} 
6. Em caso de erro na Clicksign: rollback local
7. Logar operação com correlation_id

**Fluxo DELETE**:
1. Validar se signatory possui ClicksignKey
2. Validar se envelope permite remoção
3. Chamar DELETE /api/v3/signers/{{clicksign_key}}
4. Se sucesso: deletar signatário localmente
5. Em caso de erro na Clicksign: manter local e logar erro
6. Logar operação com correlation_id

### Validações de Negócio Necessárias

**Validações Antes de Operações Clicksign**:
- Envelope deve ter ClicksignKey preenchida
- Signatário deve ter ClicksignKey preenchida (exceto CREATE)
- Status do envelope deve permitir modificação de signatários
- Conectividade com Clicksign deve estar funcionando

**Estados de Envelope que Permitem Modificação**:
- `draft` - Permite CREATE/UPDATE/DELETE
- `sent` - Permite apenas CREATE (conforme lógica atual)
- `pending`, `completed`, `cancelled` - Não permite modificações

### Estratégia de Rollback

**CREATE Signatory**:
- Se falha na Clicksign: deletar registro local criado
- Se falha ao salvar ClicksignKey: tentar deletar da Clicksign

**UPDATE Signatory**:
- Se falha na Clicksign: reverter campos alterados no banco local
- Manter backup dos valores originais antes da atualização

**DELETE Signatory**:
- Se falha na Clicksign: não deletar localmente
- Logar inconsistência para correção manual posterior

### Campos de Log Necessários

**Logging Estruturado**:
```go
logger.WithFields(logrus.Fields{
    "correlation_id":     correlationID,
    "signatory_id":       signatory.ID,
    "signatory_email":    signatory.Email,
    "envelope_id":        signatory.EnvelopeID,
    "envelope_clicksign_key": envelope.ClicksignKey,
    "signatory_clicksign_key": signatory.ClicksignKey,
    "operation":          "update_signatory",
    "step":               "clicksign_api_call",
    "duration_ms":        duration.Milliseconds(),
}).Info("Signatory updated successfully in Clicksign")
```

### Testing Strategy

**Cenários de Teste Necessários**:

1. **UPDATE Signatory**:
   - Atualização com sucesso na Clicksign
   - Falha na API Clicksign (404, 422, 500)
   - Rollback em caso de falha
   - Validação de ClicksignKey ausente

2. **DELETE Signatory**:
   - Remoção com sucesso na Clicksign
   - Falha na API Clicksign
   - Signatário não existe na Clicksign (404)
   - Envelope não permite remoção

3. **CREATE Signatory**:
   - Criação com dados completos e parciais
   - Rollback em caso de falha na Clicksign
   - Validação de envelope sem ClicksignKey

4. **Mapeamento Bidirecional**:
   - Todos os campos mapeados corretamente
   - Campos opcionais tratados adequadamente
   - CommunicateEvents mapeados corretamente

### Arquivos a Modificar

**Infrastructure Layer**:
- `src/infrastructure/clicksign/signer_service.go` - Adicionar UpdateSigner, DeleteSigner
- `src/infrastructure/clicksign/signatory_mapper.go` - Adicionar métodos de mapeamento

**UseCase Layer**:
- `src/usecase/signatory/usecase_signatory_service.go` - Integrar UPDATE/DELETE com Clicksign

**Testing**:
- `src/usecase/signatory/usecase_signatory_service_test.go` - Adicionar testes de integração
- `src/infrastructure/clicksign/signer_service_test.go` - Testes dos novos métodos

### Performance e Reliability

**Considerações de Performance**:
- Timeout adequado para chamadas Clicksign (30s)
- Retry automático para erros temporários (3x)
- Cache de validação de ClicksignKey quando possível

**Reliability**:
- Circuit breaker para falhas consecutivas na Clicksign
- Queue de sincronização para operações com falha
- Monitoring de taxa de sucesso das operações Clicksign

## Implementation Summary

**Data de Criação**: 2025-07-25
**Status**: 📋 Ready for Implementation

### Problemas Identificados

1. **UPDATE não sincroniza**: `PUT /api/v1/signatories/{id}` não atualiza na Clicksign
2. **DELETE não sincroniza**: `DELETE /api/v1/signatories/{id}` não remove da Clicksign  
3. **CREATE pode ter issues**: Necessário validação completa da integração
4. **Falta mapeamento bidirecional**: Apenas CREATE→Clicksign implementado
5. **Sem rollback**: Falhas na Clicksign não fazem rollback local
6. **Logging insuficiente**: Dificulta troubleshooting de problemas de integração

### Solução Proposta

🔧 **Implementar integração completa CRUD** com Clicksign mantendo consistência entre sistemas local e remoto através de:

- Métodos UpdateSigner/DeleteSigner no SignerService
- Integração no UseCase com tratamento de erros robusto  
- Mapeamento bidirecional completo EntitySignatory ↔ Clicksign
- Estratégia de rollback para manter consistência
- Logging estruturado para troubleshooting
- Validações de ClicksignKey e status de envelope
- Testes unitários abrangentes

### Benefícios Esperados

✅ **Sincronização completa** entre ms-docsigner e Clicksign
✅ **Rollback automático** em caso de falhas na integração  
✅ **Troubleshooting facilitado** com logging estruturado
✅ **Confiabilidade aumentada** com validações e tratamento de erros
✅ **Cobertura de testes** para garantir qualidade da integração

## Testing

**Testing Strategy**: Testes unitários abrangentes com mocks para validar integração CRUD completa com Clicksign, incluindo cenários de sucesso, falha e rollback.

## Change Log

| Date       | Version | Description                                                      | Author             |
| ---------- | ------- | ---------------------------------------------------------------- | ------------------ |
| 2025-07-25 | 1.0     | Story criada para correção integração signatários Clicksign API | Sarah (PO)         |