# Story 3.4: Extensão Response Envelope com Dados Clicksign

## Status

Approved

## Story

**Como** desenvolvedor consumindo a API,
**Eu quero** que o endpoint de criação de envelope retorne também os dados brutos da resposta do Clicksign,
**Para que** eu tenha acesso completo aos dados retornados pela API do Clicksign sem processamento ou mapeamento, permitindo análise detalhada e debugging.

## Acceptance Criteria

1. A entidade EntityEnvelope deve incluir um novo campo para armazenar os dados brutos da resposta do Clicksign
2. Os dados da resposta do Clicksign devem ser persistidos exatamente como retornados pela API, sem tratamento ou mapeamento
3. O campo deve ser do tipo JSON/texto para suportar a estrutura completa da resposta
4. O endpoint de criação de envelope deve retornar este novo campo na resposta HTTP
5. O endpoint de consulta de envelope deve incluir os dados do Clicksign na resposta
6. A persistência deve ocorrer apenas quando a criação no Clicksign for bem-sucedida
7. Em caso de falha na criação do Clicksign, o campo deve permanecer nulo/vazio
8. O campo deve ser opcional na resposta para manter compatibilidade retroativa
9. Logs estruturados devem incluir informação sobre a persistência dos dados brutos
10. Testes unitários devem cobrir todos os cenários: sucesso com dados, falha sem dados, consulta com dados

## Tasks / Subtasks

- [ ] Estender entidade EntityEnvelope com campo para dados Clicksign (AC: 1, 3)

  - [ ] Adicionar campo `ClicksignRawData` do tipo string/JSON na struct EntityEnvelope
  - [ ] Atualizar migrations de banco de dados para incluir nova coluna
  - [ ] Modificar construtor NewEnvelope para aceitar dados brutos opcionais
  - [ ] Implementar método SetClicksignRawData para atualizar os dados após criação no Clicksign

- [ ] Modificar DTO de response para incluir dados Clicksign (AC: 4, 5, 8)

  - [ ] Estender EnvelopeResponseDTO com campo opcional `clicksign_raw_data`
  - [ ] Atualizar mapeamento de entidade para DTO para incluir novos dados
  - [ ] Garantir que o campo seja omitido quando vazio para compatibilidade retroativa
  - [ ] Documentar nova estrutura no comentário do DTO

- [ ] Atualizar EnvelopeService para capturar resposta bruta (AC: 2, 6, 7)

  - [ ] Modificar método CreateEnvelope para retornar tanto o ID quanto os dados brutos
  - [ ] Preservar resposta JSON original antes do parse para extração do ID
  - [ ] Implementar validação para garantir que dados sejam válidos JSON
  - [ ] Manter tratamento de erro existente quando criação falha

- [ ] Modificar UseCase de envelope para persistir dados brutos (AC: 2, 6)

  - [ ] Atualizar interface IUsecaseEnvelope para incluir dados brutos na resposta
  - [ ] Modificar UsecaseEnvelopeService.CreateEnvelope para receber e persistir dados
  - [ ] Implementar chamada do método SetClicksignRawData após criação bem-sucedida
  - [ ] Atualizar CreateEnvelopeWithDocuments para incluir mesma funcionalidade

- [ ] Atualizar handler CreateEnvelopeHandler (AC: 4, 9)

  - [ ] Modificar lógica para processar dados brutos retornados pelo UseCase
  - [ ] Atualizar mapeamento de resposta para incluir dados do Clicksign
  - [ ] Adicionar logging estruturado para persistência de dados brutos
  - [ ] Manter compatibilidade com fluxo existente quando dados não disponíveis

- [ ] Atualizar handler GetEnvelopeHandler (AC: 5)

  - [ ] Verificar se mapeamento atual já inclui novos campos automaticamente
  - [ ] Testar resposta de consulta com dados brutos presentes
  - [ ] Garantir que resposta seja compatível com clientes existentes

- [ ] Implementar migrations de banco de dados (AC: 1, 3)

  - [ ] Criar migration para adicionar coluna `clicksign_raw_data` na tabela `envelopes`
  - [ ] Definir tipo como TEXT/JSON dependendo do PostgreSQL disponível
  - [ ] Configurar coluna como nullable para manter compatibilidade
  - [ ] Testar migration em ambiente de desenvolvimento

- [ ] Implementar testes unitários abrangentes (AC: 10)

  - [ ] Testar criação de envelope com dados brutos do Clicksign
  - [ ] Testar criação com falha no Clicksign (campo deve ficar nulo)
  - [ ] Testar consulta de envelope com dados brutos presentes
  - [ ] Testar consulta de envelope sem dados brutos (retrocompatibilidade)
  - [ ] Testar mapeamento de DTO com dados presentes e ausentes
  - [ ] Verificar logs estruturados em todos os cenários
  - [ ] Testar migration de banco de dados

- [ ] Atualizar documentação Swagger (AC: 4, 5, 8)
  - [ ] Atualizar anotações @Success para incluir novo campo `clicksign_raw_data`
  - [ ] Documentar que campo é opcional e contém dados brutos do Clicksign
  - [ ] Incluir exemplo de resposta com dados brutos
  - [ ] Atualizar swagger.json automaticamente via swaggo

## Dev Notes

### Contexto das Stories Anteriores

**Story 3.3 - CreateEnvelopeHandler com Signatários Completo** [Fonte: docs/stories/3.3.extensao-create-envelope-handler-signatarios.md]:

- Handler CreateEnvelopeHandler já implementado com funcionalidade completa
- Integração com Clicksign funcionando via EnvelopeService.CreateEnvelope()
- DTOs EnvelopeCreateRequestDTO e EnvelopeResponseDTO já estruturados
- Logging estruturado e tratamento de erros implementados
- Testes unitários abrangentes já existem como referência
- Compatibilidade retroativa estabelecida como padrão

**Story 2.3 - Integração Clicksign Funcional** [Fonte: docs/stories/2.3.criacao-envelopes-clicksign.md]:

- EnvelopeService implementado em `src/infrastructure/clicksign/envelope_service.go`
- Método CreateEnvelope atual retorna apenas string (ID do envelope)
- Response bruta é lida mas apenas o ID é extraído e retornado
- Estrutura JSON API do Clicksign já compreendida (EnvelopeCreateResponseWrapper)

### Especificações Técnicas

**Entidade Atual EntityEnvelope** [Fonte: src/entity/entity_envelope.go]:

```go
type EntityEnvelope struct {
    ID              int        `json:"id" gorm:"primaryKey"`
    Name            string     `json:"name" gorm:"not null"`
    // ... outros campos existentes
    ClicksignKey    string     `json:"clicksign_key" gorm:"index"`
    CreatedAt       time.Time  `json:"created_at"`
    UpdatedAt       time.Time  `json:"updated_at"`
}
```

**Extensão Proposta**:

```go
type EntityEnvelope struct {
    // ... campos existentes
    ClicksignKey     string  `json:"clicksign_key" gorm:"index"`
    ClicksignRawData *string `json:"clicksign_raw_data" gorm:"type:text"`
    CreatedAt        time.Time  `json:"created_at"`
    UpdatedAt        time.Time  `json:"updated_at"`
}
```

**DTO de Response Atual** [Fonte: src/api/handlers/dtos/envelope_dto.go]:

```go
type EnvelopeResponseDTO struct {
    ID              int                     `json:"id"`
    Name            string                  `json:"name"`
    // ... outros campos
    ClicksignKey    string                  `json:"clicksign_key"`
    CreatedAt       time.Time               `json:"created_at"`
    UpdatedAt       time.Time               `json:"updated_at"`
}
```

**Extensão Proposta**:

```go
type EnvelopeResponseDTO struct {
    // ... campos existentes
    ClicksignKey     string  `json:"clicksign_key"`
    ClicksignRawData *string `json:"clicksign_raw_data,omitempty"`
    CreatedAt        time.Time  `json:"created_at"`
    UpdatedAt        time.Time  `json:"updated_at"`
}
```

**EnvelopeService Atual** [Fonte: src/infrastructure/clicksign/envelope_service.go]:

- Método `CreateEnvelope(ctx, envelope) (string, error)` atual retorna apenas ID
- Response bruta é lida em `body` mas descartada após parse
- Estrutura `EnvelopeCreateResponseWrapper` já implementada para parse

**Modificação Proposta**:

```go
// Nova interface no método CreateEnvelope
CreateEnvelope(ctx context.Context, envelope *entity.EntityEnvelope) (string, string, error)
// Retorna: (clicksignID, rawData, error)
```

**UseCase Interface Atual** [Fonte: src/usecase/envelope/usecase_envelope_interface.go]:

- Interface `IUsecaseEnvelope` com método `CreateEnvelope(*entity.EntityEnvelope) (*entity.EntityEnvelope, error)`
- Implementação em `UsecaseEnvelopeService.CreateEnvelope()` chama EnvelopeService

**Integração Points**:

- `UsecaseEnvelopeService.CreateEnvelope()` precisa capturar dados brutos
- `UsecaseEnvelopeService.CreateEnvelopeWithDocuments()` também precisa incluir funcionalidade
- Handler `CreateEnvelopeHandler` precisa processar novos dados na resposta

### Padrões de Clean Architecture

**Estrutura de Dados** [Fonte: docs/architecture/component-architecture.md]:

- Entities devem conter dados de negócio fundamentais
- Use Cases orquestram fluxo entre camadas
- Handlers fazem mapeamento entre protocolos e Use Cases
- Infrastructure implementa interfaces definidas pelos Use Cases

**Migration de Banco** [Fonte: docs/architecture/coding-standards-and-conventions.md]:

- Mudanças de schema devem ser backward compatible
- Novas colunas devem ser nullable inicialmente
- Usar tipo TEXT para PostgreSQL para flexibilidade máxima

### Implementação de Dados Brutos

**Estrutura dos Dados Clicksign** [Fonte: src/infrastructure/clicksign/envelope_service.go]:

O Clicksign retorna resposta no formato JSON API:

```json
{
  "data": {
    "id": "uuid-envelope",
    "type": "envelopes",
    "attributes": {
      "name": "Nome do Envelope",
      "status": "draft",
      "locale": "pt-BR"
      // ... outros atributos
    }
  }
}
```

**Estratégia de Armazenamento**:

- Armazenar response completa como string JSON
- Não fazer parse ou validação dos dados brutos
- Permitir NULL para envelopes criados antes da funcionalidade
- Usar tipo TEXT para máxima compatibilidade

### Validações e Regras de Negócio

**Compatibilidade Retroativa**:

- Campo `clicksign_raw_data` opcional em todos os DTOs
- Response omite campo quando vazio (tag `omitempty`)
- Envelopes existentes continuam funcionando normalmente
- Falhas na captura de dados não impedem criação do envelope

**Validações Específicas**:

- Dados brutos devem ser JSON válido quando presentes
- Persistência só ocorre após sucesso na criação do Clicksign
- Campo permanece NULL em caso de falha na integração
- Não validar estrutura específica dos dados (armazenar "as is")

### Testing Strategy

**Testing Strategy** [Fonte: docs/architecture/testing-strategy.md]:

- Framework padrão Go (`testing`) + biblioteca `testify`
- Mocks organizados em `/mocks/` para interfaces
- Testes unitários obrigatórios para handlers com dependencies mockadas
- Cobertura de cenários de sucesso e falha

**Cenários de Teste Específicos**:

- Criação de envelope com resposta Clicksign bem-sucedida
- Criação de envelope com falha no Clicksign (dados devem ficar NULL)
- Consulta de envelope com dados brutos presentes
- Consulta de envelope criado antes da funcionalidade (sem dados)
- Mapeamento de DTO com dados presentes e ausentes
- Migration de banco de dados
- Validação de JSON nos dados brutos
- Logging de persistência de dados

### Estrutura de Arquivos Afetados

**Arquivos a Modificar**:

- `src/entity/entity_envelope.go` - Adicionar campo ClicksignRawData
- `src/api/handlers/dtos/envelope_dto.go` - Estender EnvelopeResponseDTO
- `src/infrastructure/clicksign/envelope_service.go` - Modificar CreateEnvelope para retornar dados brutos
- `src/usecase/envelope/usecase_envelope_interface.go` - Não necessário mudança (compatibilidade mantida)
- `src/usecase/envelope/usecase_envelope_service.go` - Modificar para capturar e persistir dados
- `src/api/handlers/handlers_envelope.go` - Atualizar mapeamento de resposta

**Arquivos de Migration**:

- Criar novo arquivo migration em `migrations/` para adicionar coluna

**Arquivos de Teste a Atualizar**:

- `src/api/handlers/handlers_envelope_test.go` - Adicionar cenários com dados brutos
- `src/usecase/envelope/usecase_envelope_service_test.go` - Testar persistência de dados
- `src/infrastructure/clicksign/envelope_service_test.go` - Testar retorno de dados brutos

### Logging Estruturado

**Campos Obrigatórios no Log**:

- correlation_id (extraído do header X-Correlation-ID)
- envelope_id (quando criado)
- clicksign_key (ID do envelope no Clicksign)
- raw_data_persisted (boolean indicando se dados foram persistidos)
- raw_data_size (tamanho dos dados em bytes)

**Exemplo de Log Estruturado**:

```go
h.Logger.WithFields(logrus.Fields{
    "correlation_id":      correlationID,
    "envelope_id":         createdEnvelope.ID,
    "clicksign_key":       createdEnvelope.ClicksignKey,
    "raw_data_persisted":  true,
    "raw_data_size":       len(rawData),
    "step":                "clicksign_data_persistence",
}).Info("Clicksign raw data persisted successfully")
```

### Considerações de Performance

**Tamanho dos Dados**:

- Response do Clicksign tipicamente < 5KB por envelope
- Usar tipo TEXT ao invés de VARCHAR para evitar limitações
- Indexação não necessária (dados para debugging/análise)

**Impacto na Consulta**:

- Campo opcional não afeta performance de consultas existentes
- Tag `omitempty` evita serialização quando vazio
- Considerar lazy loading em futuras otimizações se necessário

## Dev Agent Record

### Completion Notes List

_[Lista será preenchida após implementação]_

### File List

_[Lista será preenchida após implementação]_

## Change Log

| Date       | Version | Description                                                   | Author             |
| ---------- | ------- | ------------------------------------------------------------- | ------------------ |
| 2025-07-19 | 1.0     | Story criada para extensão de resposta com dados do Clicksign | Bob (Scrum Master) |
