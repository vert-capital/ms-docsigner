# Story 3.4: Extensão Response Envelope com Dados Clicksign e Armazenamento JSON

## Status

Draft

## Story

**Como** desenvolvedor consumindo a API de criação de envelopes,
**Eu quero** receber dados completos do Clicksign na resposta e ter esses dados armazenados no banco,
**Para que** possa acessar informações detalhadas do envelope do Clicksign sem precisar fazer chamadas adicionais à API externa, e futuras atualizações via webhook possam atualizar esses dados localmente.

## Acceptance Criteria

1. O endpoint de criação de envelope deve retornar dados completos do Clicksign na resposta
2. A entidade Envelope deve ter um campo JSON para armazenar a resposta completa do Clicksign
3. O Clicksign envelope ID deve ser armazenado adequadamente no banco de dados
4. Os dados do Clicksign devem ser persistidos imediatamente após criação bem-sucedida no Clicksign
5. A resposta da API deve incluir tanto os dados locais quanto os dados do Clicksign
6. O campo JSON deve ser estruturado para permitir atualizações futuras via webhook
7. Compatibilidade retroativa deve ser mantida para clientes existentes
8. Testes unitários devem cobrir o armazenamento e recuperação dos dados do Clicksign
9. Logs estruturados devem rastrear o armazenamento dos dados do Clicksign
10. Documentação Swagger deve ser atualizada para refletir os novos campos na resposta

## Tasks / Subtasks

- [ ] Estender entidade Envelope para armazenamento de dados Clicksign (AC: 2, 3)
  - [ ] Adicionar campo `ClicksignData` do tipo JSON à EntityEnvelope
  - [ ] Criar estrutura para dados do Clicksign que mapeia a resposta da API
  - [ ] Implementar métodos para definir e recuperar dados do Clicksign
  - [ ] Atualizar validação da entidade para incluir novo campo
  - [ ] Criar migração de banco de dados para adicionar coluna clicksign_data

- [ ] Modificar Clicksign EnvelopeService para retornar dados completos (AC: 1, 4)
  - [ ] Atualizar método CreateEnvelope para retornar dados completos da resposta
  - [ ] Implementar mapeamento da resposta do Clicksign para estrutura local
  - [ ] Garantir que dados sejam capturados de forma robusta
  - [ ] Adicionar tratamento de erro específico para falhas de parsing

- [ ] Atualizar UseCase de Envelope para persistir dados do Clicksign (AC: 4, 6)
  - [ ] Modificar CreateEnvelopeWithDocuments para armazenar dados do Clicksign
  - [ ] Implementar lógica para atualizar envelope com dados do Clicksign após criação
  - [ ] Garantir que falha no armazenamento não afete criação do envelope
  - [ ] Preparar estrutura para futuras atualizações via webhook

- [ ] Estender DTOs de Response para incluir dados do Clicksign (AC: 5, 7)
  - [ ] Adicionar campo opcional `clicksign_data` ao EnvelopeResponseDTO
  - [ ] Criar estrutura ClicksignDataResponseDTO para dados estruturados
  - [ ] Implementar mapeamento de dados do Clicksign para DTO de resposta
  - [ ] Garantir compatibilidade retroativa com respostas existentes

- [ ] Modificar handlers para processar e retornar dados do Clicksign (AC: 1, 5)
  - [ ] Atualizar CreateEnvelopeHandler para lidar com dados do Clicksign
  - [ ] Implementar lógica para incluir dados do Clicksign na resposta
  - [ ] Adicionar tratamento de erro para falhas específicas do Clicksign
  - [ ] Garantir que dados locais sejam retornados mesmo se dados do Clicksign falharem

- [ ] Implementar logging estruturado para dados do Clicksign (AC: 9)
  - [ ] Adicionar logs para armazenamento de dados do Clicksign
  - [ ] Registrar tamanho e campos principais dos dados armazenados
  - [ ] Implementar logging de falhas específicas no processamento de dados
  - [ ] Manter correlation_id através de todo o processo

- [ ] Desenvolver testes unitários abrangentes (AC: 8)
  - [ ] Testar armazenamento de dados do Clicksign na entidade
  - [ ] Testar mapeamento de resposta do Clicksign para DTO local
  - [ ] Testar criação de envelope com armazenamento de dados do Clicksign
  - [ ] Testar cenários de falha no armazenamento de dados do Clicksign
  - [ ] Testar compatibilidade retroativa com envelopes sem dados do Clicksign
  - [ ] Verificar logs estruturados em todos os cenários

- [ ] Atualizar documentação Swagger (AC: 10)
  - [ ] Documentar novo campo clicksign_data na resposta de envelope
  - [ ] Incluir exemplos de response com dados do Clicksign
  - [ ] Documentar estrutura dos dados do Clicksign
  - [ ] Atualizar swagger.json automaticamente via swaggo

## Dev Notes

### Contexto das Stories Anteriores

**Story 3.3 - Extensão CreateEnvelopeHandler Implementada** [Fonte: docs/stories/3.3.extensao-create-envelope-handler-signatarios.md]:

- CreateEnvelopeHandler já estendido para criar envelope, documentos e signatários em única operação
- Estrutura transacional implementada com logging detalhado
- DTOs EnvelopeCreateRequestDTO e EnvelopeResponseDTO já incluem signatários
- Injeção de dependências configurada com UsecaseSignatory
- Testes unitários abrangentes já implementados
- Compatibilidade retroativa garantida

### Especificações Técnicas

**Entidade Envelope Atual** [Fonte: src/entity/entity_envelope.go]:

- Localizada em `/home/ubuntu/projetos/ms-docsigner/src/entity/entity_envelope.go`
- Já possui campo ClicksignKey para armazenar ID do envelope no Clicksign
- Estrutura bem definida com validações e métodos de manipulação
- Suporte a campos JSON via GORM (DocumentsIDs, SignatoryEmails)

**Estrutura Proposta para Dados do Clicksign**:

```go
type EntityEnvelope struct {
    // ... campos existentes
    ClicksignData     json.RawMessage `json:"clicksign_data,omitempty" gorm:"type:jsonb"`
}

type ClicksignEnvelopeData struct {
    ID             string                 `json:"id"`
    Name           string                 `json:"name"`
    Status         string                 `json:"status"`
    Locale         string                 `json:"locale"`
    AutoClose      bool                   `json:"auto_close"`
    RemindInterval int                    `json:"remind_interval"`
    DeadlineAt     *time.Time             `json:"deadline_at"`
    DefaultSubject string                 `json:"default_subject"`
    CreatedAt      time.Time              `json:"created_at"`
    UpdatedAt      time.Time              `json:"updated_at"`
    DocumentsCount int                    `json:"documents_count,omitempty"`
    SignersCount   int                    `json:"signers_count,omitempty"`
    Metadata       map[string]interface{} `json:"metadata,omitempty"`
}
```

**Clicksign Service Atual** [Fonte: src/infrastructure/clicksign/envelope_service.go]:

- Método CreateEnvelope retorna apenas string (envelope ID)
- Resposta completa do Clicksign está disponível mas não é utilizada
- Estruturas DTO bem definidas para resposta (EnvelopeCreateResponseWrapper)
- Logging estruturado já implementado

**DTOs de Response Disponíveis** [Fonte: src/infrastructure/clicksign/dto/envelope_dto.go]:

```go
type EnvelopeCreateResponseWrapper struct {
    Data EnvelopeCreateResponseData `json:"data"`
}

type EnvelopeCreateResponseData struct {
    Type       string                         `json:"type"`
    ID         string                         `json:"id"`
    Attributes EnvelopeCreateResponseAttributes `json:"attributes"`
}

type EnvelopeCreateResponseAttributes struct {
    Name           string     `json:"name"`
    Status         string     `json:"status"`
    Locale         string     `json:"locale"`
    AutoClose      bool       `json:"auto_close"`
    RemindInterval int        `json:"remind_interval"`
    DeadlineAt     *time.Time `json:"deadline_at"`
    DefaultSubject string     `json:"default_subject"`
    CreatedAt      time.Time  `json:"created_at"`
    UpdatedAt      time.Time  `json:"updated_at"`
}
```

### Padrões de Clean Architecture

**Estrutura de Entidades** [Fonte: docs/architecture/component-architecture.md]:

- Entidades devem conter regras de negócio fundamentais
- Campos JSON suportados via GORM para dados estruturados
- Validação deve ocorrer na camada de entidade
- Métodos de manipulação devem estar na própria entidade

**Padrões de UseCase** [Fonte: docs/architecture/component-architecture.md]:

- UseCases orquestram fluxo entre entidades e infraestrutura
- Dependem de interfaces, não implementações concretas
- Tratamento de erros na camada onde ocorrem
- Logging estruturado para rastreabilidade

### Implementação Proposta

**Modificação do Clicksign EnvelopeService**:

```go
func (s *EnvelopeService) CreateEnvelope(ctx context.Context, envelope *entity.EntityEnvelope) (*dto.EnvelopeCreateResponseWrapper, error) {
    // ... lógica existente de criação
    
    // Retornar resposta completa ao invés de apenas ID
    return &createResponse, nil
}
```

**Extensão da Entidade Envelope**:

```go
func (e *EntityEnvelope) SetClicksignData(data *dto.EnvelopeCreateResponseWrapper) error {
    clicksignData := ClicksignEnvelopeData{
        ID:             data.Data.ID,
        Name:           data.Data.Attributes.Name,
        Status:         data.Data.Attributes.Status,
        // ... outros campos
    }
    
    jsonData, err := json.Marshal(clicksignData)
    if err != nil {
        return err
    }
    
    e.ClicksignData = jsonData
    e.UpdatedAt = time.Now()
    return nil
}

func (e *EntityEnvelope) GetClicksignData() (*ClicksignEnvelopeData, error) {
    if len(e.ClicksignData) == 0 {
        return nil, nil
    }
    
    var data ClicksignEnvelopeData
    err := json.Unmarshal(e.ClicksignData, &data)
    return &data, err
}
```

**Atualização do UseCase**:

```go
func (u *UsecaseEnvelopeService) CreateEnvelopeWithDocuments(ctx context.Context, envelope *entity.EntityEnvelope, documents []*entity.EntityDocument) (*entity.EntityEnvelope, error) {
    // ... lógica existente de criação
    
    // Após criação bem-sucedida no Clicksign
    clicksignResponse, err := u.clicksignEnvelopeService.CreateEnvelope(ctx, createdEnvelope)
    if err != nil {
        return nil, err
    }
    
    // Armazenar dados do Clicksign
    if err := createdEnvelope.SetClicksignData(clicksignResponse); err != nil {
        u.logger.WithError(err).Warn("Failed to store Clicksign data, continuing with envelope creation")
    } else {
        // Atualizar envelope no banco com dados do Clicksign
        if _, err := u.repository.Update(ctx, createdEnvelope); err != nil {
            u.logger.WithError(err).Warn("Failed to persist Clicksign data to database")
        }
    }
    
    return createdEnvelope, nil
}
```

### Estrutura de Arquivos Afetados

**Arquivos a Modificar**:

- `src/entity/entity_envelope.go` - Adicionar campo ClicksignData e métodos
- `src/infrastructure/clicksign/envelope_service.go` - Retornar dados completos
- `src/usecase/envelope/usecase_envelope_service.go` - Armazenar dados do Clicksign
- `src/api/handlers/dtos/envelope_dto.go` - Estender response DTO
- `src/api/handlers/handlers_envelope.go` - Incluir dados do Clicksign na resposta

**Migração de Banco de Dados**:

```sql
ALTER TABLE envelopes ADD COLUMN clicksign_data JSONB;
CREATE INDEX idx_envelopes_clicksign_data_id ON envelopes USING GIN ((clicksign_data->>'id'));
```

### Validações e Regras de Negócio

**Armazenamento de Dados**:

- Dados do Clicksign são opcionais (podem não existir para envelopes antigos)
- Falha no armazenamento de dados não deve impedir criação do envelope
- Dados devem ser estruturados para permitir atualizações via webhook
- Campo JSON permite flexibilidade para futuras extensões

**Compatibilidade Retroativa**:

- Campo clicksign_data opcional na resposta
- Envelopes existentes continuam funcionando normalmente
- Response structure mantém campos existentes
- Novos dados são adicionais, não substitutos

### Testing

**Testing Strategy** [Fonte: docs/architecture/testing-strategy.md]:

- Framework padrão Go (`testing`) + biblioteca `testify`
- Mocks organizados em `/mocks/` para interfaces
- Testes unitários para todas as camadas (entity, usecase, handler)
- Cobertura de cenários de sucesso e falha

**Cenários de Teste Específicos**:

- Criação de envelope com armazenamento bem-sucedido de dados do Clicksign
- Criação de envelope com falha no armazenamento de dados (envelope deve ser criado)
- Recuperação de dados do Clicksign de envelope existente
- Envelope sem dados do Clicksign (compatibilidade retroativa)
- Parsing inválido de dados do Clicksign
- Migração de banco de dados com dados existentes
- Response API incluindo dados do Clicksign

### Logging Estruturado

**Campos Obrigatórios no Log**:

- correlation_id (extraído do header X-Correlation-ID)
- envelope_id (local e do Clicksign)
- clicksign_data_size (tamanho dos dados JSON armazenados)
- clicksign_status (status retornado pelo Clicksign)
- storage_success (se o armazenamento foi bem-sucedido)

**Exemplo de Log Estruturado**:

```go
h.Logger.WithFields(logrus.Fields{
    "correlation_id":      correlationID,
    "envelope_id":        envelope.ID,
    "clicksign_key":      envelope.ClicksignKey,
    "clicksign_data_size": len(envelope.ClicksignData),
    "clicksign_status":   clicksignData.Status,
    "storage_success":    true,
}).Info("Clicksign data stored successfully")
```

### Preparação para Webhooks Futuros

**Estrutura Extensível**:

- Campo JSON permite atualizações flexíveis
- Estrutura ClicksignEnvelopeData pode ser estendida
- Métodos SetClicksignData/GetClicksignData facilitam manipulação
- Índice na coluna JSON para consultas eficientes

**Webhook Integration Points**:

- Dados armazenados podem ser atualizados via webhook endpoints futuros
- Estrutura permite merge de dados existentes com atualizações
- Status changes podem ser refletidos nos dados locais
- Timestamp tracking para controle de versão
