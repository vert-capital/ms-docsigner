# Story 3.2: Handlers HTTP para Gerenciamento de Signatários

## Status

Draft

## Story

**Como** desenvolvedor do sistema,
**Eu quero** implementar handlers HTTP para gerenciamento completo de signatários,
**Para que** a API ofereça endpoints funcionais para criar, listar, atualizar e remover signatários de envelopes, incluindo integração com a API Clicksign.

## Acceptance Criteria

1. Handler POST /api/v1/envelopes/{envelope_id}/signatories deve criar signatários associados a envelopes
2. Handler GET /api/v1/envelopes/{envelope_id}/signatories deve listar signatários de um envelope específico
3. Handler GET /api/v1/signatories/{id} deve retornar detalhes de um signatário específico
4. Handler PUT /api/v1/signatories/{id} deve atualizar informações de um signatário
5. Handler DELETE /api/v1/signatories/{id} deve remover um signatário
6. Handler POST /api/v1/envelopes/{envelope_id}/send deve enviar signatários para Clicksign após criação do envelope
7. Todos os handlers devem seguir padrões de validação, logging e tratamento de erros existentes
8. Integração com API Clicksign deve ser implementada para sincronização de signatários
9. Documentação Swagger deve ser atualizada para novos endpoints
10. Testes unitários devem cobrir todos os handlers implementados

## Tasks / Subtasks

- [ ] Criar handlers básicos para gerenciamento de signatários (AC: 1, 2, 3, 4, 5)
  - [ ] Implementar SignatoryHandlers struct seguindo padrão de handlers existentes
  - [ ] Criar handler CreateSignatoryHandler para POST /api/v1/envelopes/{envelope_id}/signatories
  - [ ] Implementar handler GetSignatoriesHandler para GET /api/v1/envelopes/{envelope_id}/signatories
  - [ ] Desenvolver handler GetSignatoryHandler para GET /api/v1/signatories/{id}
  - [ ] Criar handler UpdateSignatoryHandler para PUT /api/v1/signatories/{id}
  - [ ] Implementar handler DeleteSignatoryHandler para DELETE /api/v1/signatories/{id}

- [ ] Implementar handler para envio de signatários ao Clicksign (AC: 6)
  - [ ] Criar handler SendSignatoriesToClicksignHandler para POST /api/v1/envelopes/{envelope_id}/send
  - [ ] Implementar lógica de sincronização com API Clicksign usando signer_service existente
  - [ ] Adicionar validação de status do envelope antes do envio
  - [ ] Implementar atualização de status dos signatários após envio bem-sucedido

- [ ] Aplicar padrões de qualidade e consistência (AC: 7)
  - [ ] Implementar validação robusta usando DTOs existentes de SignatoryCreateRequestDTO
  - [ ] Adicionar logging estruturado com correlation IDs seguindo padrão de EnvelopeHandlers
  - [ ] Implementar tratamento de erros padronizado com ErrorResponseDTO
  - [ ] Adicionar validação de permissões e autenticação nos handlers
  - [ ] Implementar helper methods para mapeamento entity-to-DTO e DTO-to-entity

- [ ] Configurar roteamento e middleware (AC: 7)
  - [ ] Criar função MountSignatoryHandlers seguindo padrão existente
  - [ ] Configurar autenticação para todos os endpoints de signatários
  - [ ] Integrar handlers com engine Gin usando grupos de rotas
  - [ ] Configurar middleware de logging e correlação

- [ ] Implementar integração Clicksign (AC: 8)
  - [ ] Utilizar clicksign.Client existente para operações de signatários
  - [ ] Implementar chamadas para endpoint POST /api/v3/envelopes/{envelope_id}/signers do Clicksign
  - [ ] Adicionar mapeamento de EntitySignatory para formato JSON API v3.0 usando signatory_mapper existente
  - [ ] Implementar sincronização bidirecional de status entre sistema local e Clicksign
  - [ ] Adicionar tratamento específico de erros da API Clicksign

- [ ] Atualizar documentação Swagger (AC: 9)
  - [ ] Adicionar anotações Swagger para todos os novos endpoints
  - [ ] Documentar estruturas de request e response DTOs
  - [ ] Incluir exemplos de uso e códigos de erro possíveis
  - [ ] Atualizar swagger.json e swagger.yaml automaticamente

- [ ] Criar testes unitários abrangentes (AC: 10)
  - [ ] Implementar testes para SignatoryHandlers em handlers_signatory_test.go
  - [ ] Criar mocks para IUsecaseSignatory e ClicksignClient
  - [ ] Testar cenários de sucesso e falha para todos os handlers
  - [ ] Validar comportamento de validação de DTOs nos handlers
  - [ ] Testar integração com middleware de autenticação
  - [ ] Implementar testes de integração para fluxo completo de signatários

## Dev Notes

### Contexto das Stories Anteriores

**História 3.1 - Entidade Signatory Implementada** [Fonte: docs/stories/3.1.entidade-signatory-casos-de-uso.md]:
- Entidade EntitySignatory já criada em `src/entity/entity_signatory.go`
- UseCase IUsecaseSignatory implementado em `src/usecase/signatory/`
- Repository IRepositorySignatory funcional em `src/infrastructure/repository/repository_signatory.go`
- DTOs SignatoryCreateRequestDTO, SignatoryResponseDTO já implementados em `src/api/handlers/dtos/signatory_dto.go`
- Mapeamento para Clicksign DTOs disponível em `src/infrastructure/clicksign/signatory_mapper.go`
- Relacionamento com envelopes estabelecido via campo envelope_id

### Especificações Técnicas

**Estrutura dos Handlers** [Fonte: docs/architecture/component-architecture.md]:
- Seguir padrão Clean Architecture: Handlers → UseCase → Repository
- Handlers devem ser responsáveis apenas por: HTTP binding, validação de entrada, chamada do UseCase, mapeamento para response
- Dependências injetadas via construtor (Dependency Injection)
- Separação clara entre regras de negócio (UseCase) e protocolo HTTP (Handler)

**Padrões de Handlers Existentes** [Fonte: src/api/handlers/handlers_envelope.go]:
- Struct Handler com dependências injetadas: UsecaseXxx, Logger
- Método construtor NewXxxHandler() para inicialização
- Correlation IDs extraídos de headers para rastreabilidade
- Logging estruturado com logrus.Fields contendo context relevante
- Validação em duas etapas: binding JSON + validação customizada DTO
- Tratamento de erros padronizado com ErrorResponseDTO e ValidationErrorResponseDTO
- Helper methods para mapeamento entity-DTO (mapEntityToResponse, mapRequestToEntity)
- Função MountXxxHandlers para configuração de rotas e middleware

**Estrutura de Response Padronizada** [Fonte: src/api/handlers/dtos/envelope_dto.go]:
```go
type ErrorResponseDTO struct {
    Error   string      `json:"error"`
    Message string      `json:"message"`
    Details interface{} `json:"details,omitempty"`
}

type ValidationErrorResponseDTO struct {
    Error   string                    `json:"error"`
    Message string                    `json:"message"`
    Details []ValidationErrorDetail   `json:"details"`
}
```

**Códigos HTTP Padronizados**:
- 201 Created - Para criação bem-sucedida
- 200 OK - Para consultas e atualizações
- 400 Bad Request - Para validação de entrada
- 404 Not Found - Para recursos não encontrados
- 500 Internal Server Error - Para erros do sistema

### Endpoints e Rotas Específicas

**Endpoints a Implementar**:
1. `POST /api/v1/envelopes/{envelope_id}/signatories` - Criar signatário
2. `GET /api/v1/envelopes/{envelope_id}/signatories` - Listar signatários do envelope
3. `GET /api/v1/signatories/{id}` - Obter signatário específico
4. `PUT /api/v1/signatories/{id}` - Atualizar signatário
5. `DELETE /api/v1/signatories/{id}` - Remover signatário
6. `POST /api/v1/envelopes/{envelope_id}/send` - Enviar signatários para Clicksign

**Padrão de Grouping de Rotas** [Fonte: src/api/handlers/handlers_envelope.go]:
```go
group := gin.Group("/api/v1/signatories")
SetAuthMiddleware(conn, group)
// Definir rotas no grupo
```

### Integração Clicksign Específica

**Cliente Clicksign Disponível** [Fonte: src/infrastructure/clicksign/client.go]:
- Interface ClicksignClientInterface já definida
- Implementação funcional em clicksign.Client com autenticação configurada
- Headers padrão: `Content-Type: application/vnd.api+json`
- Tratamento de rate limiting e retry logic implementados

**Signer Service Existente** [Fonte: src/infrastructure/clicksign/signer_service.go]:
- Métodos disponíveis para operações com signatários na API Clicksign
- Endpoint base: `/api/v3/envelopes/{envelope_id}/signers`
- Formato esperado: JSON API v3.0 specification

**Mapeamento para Clicksign** [Fonte: src/infrastructure/clicksign/signatory_mapper.go]:
- Função ToClicksignCreateRequest(signatory) já implementada
- Conversão automática de EntitySignatory para formato JSON API v3.0
- Tratamento de campos opcionais conforme especificação Clicksign

### Validações e Regras de Negócio

**Validações Obrigatórias** [Fonte: src/entity/entity_signatory.go]:
- Email único por envelope (validação no repository)
- Envelope deve existir e estar no status adequado para adição de signatários
- Campos obrigatórios: name, email, envelope_id
- Campos opcionais com validação: birthday (YYYY-MM-DD), phone_number (formato internacional)

**UseCase Methods Disponíveis** [Fonte: src/usecase/signatory/usecase_signatory_interface.go]:
- CreateSignatory(signatory *entity.EntitySignatory) error
- GetSignatory(id int) (*entity.EntitySignatory, error)
- GetSignatoriesByEnvelope(envelopeID int) ([]entity.EntitySignatory, error)
- UpdateSignatory(signatory *entity.EntitySignatory) error
- DeleteSignatory(id int) error
- AssociateWithEnvelope(signatoryID, envelopeID int) error

### Arquivos a Criar

**Handler Principal**:
- `src/api/handlers/handlers_signatory.go` - Implementação dos handlers HTTP

**Testes**:
- `src/api/handlers/handlers_signatory_test.go` - Testes unitários dos handlers

**Integração em APIs**:
- Atualizar `src/api/handlers/api.go` para incluir MountSignatoryHandlers

### Estrutura do Handler Principal

```go
type SignatoryHandlers struct {
    UsecaseSignatory signatory.IUsecaseSignatory
    UsecaseEnvelope  envelope.IUsecaseEnvelope  // Para validação de envelope
    Logger          *logrus.Logger
}

func NewSignatoryHandler(
    usecaseSignatory signatory.IUsecaseSignatory,
    usecaseEnvelope envelope.IUsecaseEnvelope,
    logger *logrus.Logger,
) *SignatoryHandlers
```

### Tratamento de Erros Específicos

**Cenários de Erro Específicos para Signatários**:
- Envelope não encontrado (404)
- Email duplicado no mesmo envelope (400)
- Signatário não encontrado (404)
- Envelope em status inválido para operação (400)
- Falha na integração com Clicksign (500 com details)
- Validação de campos opcionais inválidos (400)

### Logging Estruturado

**Campos Obrigatórios no Log**:
- correlation_id (extraído do header X-Correlation-ID)
- signatory_id (quando aplicável)
- envelope_id (sempre presente)
- endpoint (método HTTP + rota)
- signatory_email (para operações de criação/atualização)

**Exemplo de Log**:
```go
h.Logger.WithFields(logrus.Fields{
    "correlation_id": correlationID,
    "endpoint":       "POST /api/v1/envelopes/{envelope_id}/signatories",
    "envelope_id":    envelopeID,
    "signatory_email": requestDTO.Email,
}).Info("Creating signatory request received")
```

### Testing Strategy

**Testing Requirements** [Fonte: docs/architecture/testing-strategy.md]:
- Framework padrão Go (`testing`) + biblioteca `testify`
- Mocks organizados em `/mocks/` para interfaces
- Testes unitários obrigatórios para handlers com dependencies mockadas
- Cobertura de cenários de sucesso e falha
- Testes de validação de entrada e saída

**Cenários de Teste Obrigatórios**:
- Criação de signatário com dados válidos
- Criação com email duplicado no mesmo envelope
- Consulta de signatário existente e inexistente
- Atualização de signatário com dados válidos e inválidos
- Remoção de signatário existente e inexistente
- Envio para Clicksign com envelope em status válido e inválido
- Falhas de integração com Clicksign
- Validação de correlation IDs nos logs

## Change Log

| Date       | Version | Description                                                    | Author             |
| ---------- | ------- | -------------------------------------------------------------- | ------------------ |
| 2025-07-19 | 1.0     | Story criada para handlers HTTP de gerenciamento de signatários | Bob (Scrum Master) |
